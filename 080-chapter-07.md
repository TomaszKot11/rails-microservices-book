### Chapter 7 - Data Relationships

## Introduction

Your application will most likely be designed on top of one or more database tables, whether they are stored in a relational database or a NoSQL database. As the application grows, you'll define relationships between entities that will need to be defined both in the application and in the database.

## Primary and Foreign Keys

Primary keys are attributes used to identify the uniqueness of a row in a relation (also known as a table in database terminology). Foreign keys are used to associate child or dependent records to another relation.

## Natural vs Surrogate Keys

The rows in most of your relations should have a unique identifier. A unique identifier could be a single attribute, or two or more attributes.

A natural key is defined as one or more attributes which uniquely identify a row. For example, in a relation where you store your employee's information, you could use their first and last name attributes as a natural key. But what happens when your company hires another person with the same first and last name? When that time comes, you'll have wished you picked a better natural key, like their Social Security number. You could use the Social Security number attribute as the natural key. Social Security numbers are unique and are assigned to a person for their entire life. Because of this, it makes a great natural key because it uniquely identifies an employee, but doesn't change like their name could.

> Note: I'm not advocating that you store Social Security numbers in your database, but this serves as a great example of a unique value that comes from an external source. Another reason not to depend on Social Security numbers as unique identifiers is that employees with green cards, etc won't have a number assigned by the Social Security Administration.

Surrogate keys are auto generated by your database system. Most surrogate keys are an integer type that usually starts at 1 and increases (+1) for each new row that is inserted.

In theory, natural keys are preferred to surrogate keys because they are composed of the data that is stored in the database. In practice, however, surrogate keys are generally easier to use and can usually be optimized for better application and database performance.

## Database vs App Generated

Surrogate keys can be generated by either the database or the application. Keys that are integer types are most commonly generated by the database, and database concurrency ensures that each new record gets a unique value in it's primary key column, whether you have one or twenty application instances inserting records into the same table.

### Database Generated Integers

The most common surrogate keys generated by a database system are integer values. When designing your database, you'll most likely need to add integer-type surrogate keys so that the data can be managed by Active Record. When designing your tables, keep in mind that you should build your data structures for the long term. By default, Rails scaffolding generates migrations that use 32 bit integer data types. For most tables, especially lookup or domain tables, this integer type is perfectly fine. For some of your tables, after a while (it could be months or years later) your application could come to a screeching halt when the 32 bit integer primary key hits its maximum value.

When you're designing your database, if you can identify which tables could continue to grow in size over time, it would be better to start with a 64 bit integer - bigint (MySQL) or bigserial (PostgreSQL) data types. If you do use a 64 bit integer for some of your tables, remember to match the type for foreign keys.

### Unique Identifiers

One way to generate surrogate keys which also keeps the surrogate keys unique is to generate unique identifiers in the application. These unique identifiers can be shared with other services. Your design could allow the database to also generate an incrementing primary key, but those values should never be shared with systems outside of the application.

Unique identifiers are sometimes called globally unique identifiers (GUIDs), or universally unique identifiers (UUIDs). UUIDs are a subset of GUIDs. GUIDs can be generated by the application before the record is persisted to the database. For all practical purposes, each GUID is unique. An example GUID is `83efd88b-ec78-4e84-b8c7-dad8421d42d4`. GUIDs are usually represented by hex digits separated by dashes. These values can be shared as a unique identifier for a specific database row or object between applications. They can also be used as foreign keys to map parent and child objects.

## When to use each

If your application is monolithic (a single application running on top of a single database), there is usually no need to use anything other than the database's auto-incrementing primary key. By default, Rails applications handle the database's surrogate key implementation quite well.

It's at the point when you decide to split your database and share data between systems that you'll need to implement some type of unique identifier that can be shared between systems. Once you reach this point, your data no longer lives in a single database or application, it is sent and shared across the network. Also, if you implement both a database-generated integer primary key and a UUID key as your microservice platform grows, the database-generated integer value has no meaning outside of its own database and application. There is no need to share the integer value, only the UUID.

## Wrap-up

Database normalization requires you to identify a primary key. This key could be a natural key (one or more columns that define the data), or a surrogate key that is generated by the application or the database. Rails is designed to use database-generated primary keys out of the box. As your infrastructure grows and as you begin to share data with other systems, using a UUID is an option that makes your data portable and uniquely identifiable.

In the next chapter, we'll discuss a way to serialize the data that will be shared between our microservices. One way to efficiently serialize the data via Protocol Buffers (aka Protobuf).

[Next >>](090-chapter-08.md)
